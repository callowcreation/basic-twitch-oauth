/*!
 * basic-twitch-oauth
 * Copyright(c) 2019-present caLLowCreation
 * MIT Licensed
 */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const fetch = require('node-fetch');
const url_1 = require("url");
class TwitchOAuth {
    constructor({ client_id, client_secret, redirect_uri, scopes }, state) {
        this.SECONDS_OFF = 60;
        this.OAUTH2_BASE_URL = 'https://id.twitch.tv/oauth2';
        this.OAUTH2_URLS = {
            AUTHORIZE: `${this.OAUTH2_BASE_URL}/authorize`,
            TOKEN: `${this.OAUTH2_BASE_URL}/token`,
            VALIDATE: `${this.OAUTH2_BASE_URL}/validate`,
            REVOKE: `${this.OAUTH2_BASE_URL}/revoke`,
        };
        this.client_id = client_id;
        this.client_secret = client_secret;
        this.redirect_uri = redirect_uri;
        this.scopes = scopes.join(' ');
        this.state = state;
        this.authenticated = {
            access_token: '',
            refresh_token: '',
            expires_in: 0,
            expires_time: 0,
            last_validated: 0
        };
        const urlParams = [
            `client_id=${this.client_id}`,
            `redirect_uri=${encodeURIComponent(this.redirect_uri)}`,
            `response_type=code`,
            `scope=${encodeURIComponent(this.scopes)}`,
            `state=${state}`
        ];
        const urlQuery = urlParams.join('&');
        this.authorizeUrl = `${this.OAUTH2_URLS.AUTHORIZE}?${urlQuery}`;
    }
    getBasicHeaders(client_id, client_secret) {
        return {
            'Authorization': 'Basic ' + (Buffer.from(client_id + ':' + client_secret).toString('base64'))
        };
    }
    getBearerHeaders(client_id, access_token) {
        return {
            'Authorization': 'Bearer ' + access_token,
            'Client-ID': client_id,
            'Content-Type': 'application/json'
        };
    }
    /**
     *
     * @param {response} res the response from the fetch request
     *
     * @throws When request fails (res.status >= 200 && res.status < 300 acceptable status)
     */
    checkStatus(res) {
        if (!res.ok)
            throw new Error(res.statusText);
        return res; // res.status >= 200 && res.status < 300
    }
    /**
     *
     * @param {response} res the response from the fetch request
     * @returns true if response status is 200
     */
    statusOk(res) {
        return res.status === 200;
    }
    async toResult(res) {
        const contentType = res.headers.get('content-type');
        return contentType && contentType.includes('application/json') ? res.json() : res.text();
    }
    /**
     *
     * @param state Your unique token, generated by your application.
     * This is an OAuth 2.0 opaque value, used to avoid CSRF attacks.
     * This value is echoed back in the response.
     * We strongly recommend you use this.
     *
     * @throws When state are not an exact match
     *
     */
    confirmState(state) {
        if (state !== this.state)
            throw new Error(`Authorization failed ${state} mismatch`);
    }
    makeAuthenticated({ access_token, refresh_token, expires_in }) {
        const d = new Date();
        const ms = d.getTime();
        return {
            access_token: access_token,
            refresh_token: refresh_token,
            expires_in: expires_in,
            expires_time: (ms + (expires_in * 1000)) - (this.SECONDS_OFF * 1000),
            last_validated: ms
        };
    }
    setAuthenticated({ access_token, refresh_token, expires_in }) {
        this.authenticated = this.makeAuthenticated({ access_token, refresh_token, expires_in });
        return access_token;
    }
    /**
     *
     * @param code The OAuth 2.0 authorization code is a 30-character,
     * randomly generated string.  It is used to make a request to the
     * token endpoint in exchange for an access token.
     *
     * @throws When request fails
     *
     */
    async fetchToken(code) {
        return fetch(this.OAUTH2_URLS.TOKEN, {
            method: 'POST',
            headers: this.getBasicHeaders(this.client_id, this.client_secret),
            body: new url_1.URLSearchParams({
                client_id: this.client_id,
                client_secret: this.client_secret,
                code: code,
                grant_type: 'authorization_code',
                redirect_uri: this.redirect_uri
            })
        })
            .then(this.checkStatus).then(this.toResult)
            .then((json) => this.setAuthenticated(json));
    }
    async fetchRefreshToken() {
        return this.fetchRefreshTokenWithCredentials(this.client_id, this.client_secret, this.authenticated.refresh_token)
            .then(json => this.setAuthenticated(json));
    }
    /**
     *
     * Does not store credentials
     *
     */
    async fetchRefreshTokenWithCredentials(client_id, client_secret, refresh_token) {
        return fetch(this.OAUTH2_URLS.TOKEN, {
            method: 'POST',
            headers: this.getBasicHeaders(client_id, client_secret),
            body: new url_1.URLSearchParams({
                client_id: client_id,
                client_secret: client_secret,
                grant_type: 'refresh_token',
                refresh_token: refresh_token
            })
        }).then(this.checkStatus).then(this.toResult);
    }
    async refreshTokenIfNeeded() {
        if (this.refreshTokenNeeded(this.authenticated)) {
            return this.fetchRefreshToken();
        }
        return this.authenticated.access_token;
    }
    refreshTokenNeeded(authenticated) {
        const d = new Date();
        const time = d.getTime();
        return time > authenticated.expires_time;
    }
    async fetchEndpoint(url, options) {
        return this.refreshTokenIfNeeded().then(access_token => this.fetchEndpointWithCredentials(this.client_id, access_token, url, options));
    }
    async fetchEndpointWithCredentials(client_id, access_token, url, options) {
        options.headers = this.getBearerHeaders(client_id, access_token);
        return fetch(url, options).then(this.checkStatus).then(this.toResult);
    }
    /**
     * @deprecated since version 1.0.14 use {@link validateToken} or {@link validate} instead
     * @param {string} client_id an application client id
     * @param {string} access_token access token for the given client id
     *
     */
    async validateWithCredentials(client_id, access_token) {
        const options = {
            method: 'GET',
            headers: this.getBearerHeaders(client_id, access_token),
        };
        return fetch(this.OAUTH2_URLS.VALIDATE, options).then(this.checkStatus).then(this.toResult);
    }
    /**
     *
     * @param {string} access_token access token for the given client id
     *
     */
    async validateToken(access_token) {
        const options = {
            headers: {
                'Authorization': `OAuth ${access_token}`
            },
            method: 'GET'
        };
        return fetch(this.OAUTH2_URLS.VALIDATE, options).then(this.statusOk);
    }
    /**
     *
     * @param {string} client_id an application client id
     * @param {string} access_token access token for the given client id
     *
     */
    async revokeToken(client_id, access_token) {
        const url = `${this.OAUTH2_URLS.REVOKE}?client_id=${client_id}&token=${access_token}`;
        const options = {
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            method: 'POST'
        };
        return fetch(url, options).then(this.statusOk);
    }
    /**
     *
     * Validate the current access token
     *
     */
    async validate() {
        return this.validateToken(this.authenticated.access_token);
    }
    /**
     *
     * Revoke the current access token
     *
     */
    async revoke() {
        return this.revokeToken(this.client_id, this.authenticated.access_token);
    }
    async request(url, options) {
        return this.refreshTokenIfNeeded().then(access_token => this.requestWithCredentials(this.client_id, access_token, url, options));
    }
    async requestWithCredentials(client_id, access_token, url, options) {
        options.headers = this.getBearerHeaders(client_id, access_token);
        return fetch(url, options).then(this.checkStatus).then(this.result);
    }
    async result(res) {
        const contentType = res.headers.get('content-type');
        if (contentType && contentType.includes('application/json'))
            return res.json();
        return res.text();
    }
    /**
     *
     * @param url Fully qualified URL.
     *
     * @throws When request fails
     *
     */
    async get(url) {
        return this.request(url, {
            method: 'GET'
        });
    }
    /**
     *
     * @param url Fully qualified URL.
     *
     * @throws When request fails
     *
     */
    async getEndpoint(url) {
        return this.fetchEndpoint(url, {
            method: 'GET'
        });
    }
    /**
     *
     * @param url Fully qualified URL.
     * @param body stringify json object.
     *
     * @throws When request fails
     *
     */
    async postEndpoint(url, body) {
        return this.fetchEndpoint(url, {
            method: 'POST',
            body: typeof body !== 'string' ? JSON.stringify(body) : body
        });
    }
    /**
     *
     * @param url Fully qualified URL.
     * @param body stringify json object.
     *
     * @throws When request fails
     *
     */
    async putEndpoint(url, body) {
        return this.fetchEndpoint(url, {
            method: 'PUT',
            body: typeof body !== 'string' ? JSON.stringify(body) : body
        });
    }
    /**
     *
     * @param url Fully qualified URL.
     * @param body stringify json object.
     *
     * @throws When request fails
     *
     */
    async patchEndpoint(url, body) {
        return this.fetchEndpoint(url, {
            method: 'PATCH',
            body: typeof body !== 'string' ? JSON.stringify(body) : body
        });
    }
    /**
     *
     * @param url Fully qualified URL.
     *
     * @throws When request fails
     *
     */
    async deleteEndpoint(url) {
        return this.fetchEndpoint(url, {
            method: 'DELETE'
        });
    }
    getAuthenticated() {
        return this.authenticated;
    }
}
exports.default = TwitchOAuth;
//# sourceMappingURL=twitch-oauth.js.map