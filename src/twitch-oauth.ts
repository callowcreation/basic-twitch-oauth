/*!
 * basic-twitch-oauth
 * Copyright(c) 2019-present caLLowCreation
 * MIT Licensed
 */

'use strict';

const fetch = require('node-fetch');
import { URLSearchParams } from 'url';

interface Authenticated {
    access_token: string;
    refresh_token: string;
    expires_in: number;
    expires_time: number;
    last_validated: number;
}

export default class TwitchOAuth {

    private SECONDS_OFF: number = 60;

    private OAUTH2_BASE_URL: string = 'https://id.twitch.tv/oauth2';
    private OAUTH2_URLS: Record<string, string> = {
        AUTHORIZE: `${this.OAUTH2_BASE_URL}/authorize`,
        TOKEN: `${this.OAUTH2_BASE_URL}/token`,
        VALIDATE: `${this.OAUTH2_BASE_URL}/validate`,
        REVOKE: `${this.OAUTH2_BASE_URL}/revoke`,
    };

    client_id: string;
    client_secret: string;
    redirect_uri: string;
    scopes: string;
    state: string;

    private authenticated: Authenticated;
    authorizeUrl: string;

    constructor({ client_id, client_secret, redirect_uri, scopes }: { client_id: string, client_secret: string, redirect_uri: string, scopes: string[] }, state: string) {
        this.client_id = client_id;
        this.client_secret = client_secret;
        this.redirect_uri = redirect_uri;
        this.scopes = scopes.join(' ');

        this.state = state;

        this.authenticated = {
            access_token: '',
            refresh_token: '',
            expires_in: 0,
            expires_time: 0,
            last_validated: 0
        };

        const urlParams = [
            `client_id=${this.client_id}`,
            `redirect_uri=${encodeURIComponent(this.redirect_uri)}`,
            `response_type=code`,
            `scope=${encodeURIComponent(this.scopes)}`,
            `state=${state}`
        ];
        const urlQuery = urlParams.join('&');

        this.authorizeUrl = `${this.OAUTH2_URLS.AUTHORIZE}?${urlQuery}`;
    }

    private getBasicHeaders(client_id: string, client_secret: string): Record<string, string> {
        return {
            'Authorization': 'Basic ' + (Buffer.from(client_id + ':' + client_secret).toString('base64'))
        };
    }

    private getBearerHeaders(client_id: string, access_token: string): Record<string, string> {
        return {
            'Authorization': 'Bearer ' + access_token,
            'Client-ID': client_id,
            'Content-Type': 'application/json'
        };
    }

    /**
     * 
     * @param {response} res the response from the fetch request
     * 
     * @throws When request fails (res.status >= 200 && res.status < 300 acceptable status)
     */
    private checkStatus(res: any): any {
        if (!res.ok) throw new Error(res.statusText);
        return res; // res.status >= 200 && res.status < 300
    }

    /**
     * 
     * @param {response} res the response from the fetch request
     * @returns true if response status is 200
     */
    private statusOk(res: any): boolean {
        return res.status === 200;
    }

    private async toResult(res: Response): Promise<any | string> {
        const contentType = res.headers.get('content-type');
        return contentType && contentType.includes('application/json') ? res.json() : res.text();
    }

    /**
     * 
     * @param state Your unique token, generated by your application. 
     * This is an OAuth 2.0 opaque value, used to avoid CSRF attacks. 
     * This value is echoed back in the response. 
     * We strongly recommend you use this.
     * 
     * @throws When state are not an exact match
     * 
     */
    confirmState(state: string): void {
        if (state !== this.state) throw new Error(`Authorization failed ${state} mismatch`);
    }

    private makeAuthenticated({ access_token, refresh_token, expires_in }: { access_token: string, refresh_token: string, expires_in: number }): Authenticated {
        const d: Date = new Date();
        const ms: number = d.getTime();
        return {
            access_token: access_token,
            refresh_token: refresh_token,
            expires_in: expires_in,
            expires_time: (ms + (expires_in * 1000)) - (this.SECONDS_OFF * 1000),
            last_validated: ms
        } as Authenticated;
    }

    private setAuthenticated({ access_token, refresh_token, expires_in }: { access_token: string, refresh_token: string, expires_in: number }): string {
        this.authenticated = this.makeAuthenticated({ access_token, refresh_token, expires_in });
        return access_token;
    }

    /**
     * 
     * @param code The OAuth 2.0 authorization code is a 30-character, 
     * randomly generated string.  It is used to make a request to the 
     * token endpoint in exchange for an access token.
     * 
     * @throws When request fails
     * 
     */
    async fetchToken(code: string): Promise<string> {
        return fetch(this.OAUTH2_URLS.TOKEN, {
            method: 'POST',
            headers: this.getBasicHeaders(this.client_id, this.client_secret),
            body: new URLSearchParams({
                client_id: this.client_id,
                client_secret: this.client_secret,
                code: code,
                grant_type: 'authorization_code',
                redirect_uri: this.redirect_uri
            })
        })
            .then(this.checkStatus).then(this.toResult)
            .then((json: any) => this.setAuthenticated(json as Authenticated));
    }

    async fetchRefreshToken(): Promise<string> {
        return this.fetchRefreshTokenWithCredentials(this.client_id, this.client_secret, this.authenticated.refresh_token)
            .then(json => this.setAuthenticated(json as Authenticated));
    }

    /**
     * 
     * Does not store credentials
     * 
     */
    private async fetchRefreshTokenWithCredentials(client_id: string, client_secret: string, refresh_token: string): Promise<any | string> {
        return fetch(this.OAUTH2_URLS.TOKEN, {
            method: 'POST',
            headers: this.getBasicHeaders(client_id, client_secret),
            body: new URLSearchParams({
                client_id: client_id,
                client_secret: client_secret,
                grant_type: 'refresh_token',
                refresh_token: refresh_token
            })
        }).then(this.checkStatus).then(this.toResult);
    }

    private async refreshTokenIfNeeded(): Promise<string> {

        if (this.refreshTokenNeeded(this.authenticated)) {
            return this.fetchRefreshToken();
        }

        return this.authenticated.access_token;
    }

    private refreshTokenNeeded(authenticated: Authenticated): boolean {
        const d: Date = new Date();
        const time: number = d.getTime();
        return time > authenticated.expires_time;
    }

    async fetchEndpoint(url: string, options: RequestInit): Promise<any | string> {
        return this.refreshTokenIfNeeded().then(access_token => this.fetchEndpointWithCredentials(this.client_id, access_token, url, options));
    }

    private async fetchEndpointWithCredentials(client_id: string, access_token: string, url: string, options: Record<string, any>): Promise<any | string> {
        options.headers = this.getBearerHeaders(client_id, access_token);
        return fetch(url, options).then(this.checkStatus).then(this.toResult);
    }

    /**
     * @deprecated since version 1.0.14 use {@link validateToken} or {@link validate} instead
     * @param {string} client_id an application client id
     * @param {string} access_token access token for the given client id
     * 
     */
    async validateWithCredentials(client_id: string, access_token: string): Promise<any | string> {
        const options = {
            method: 'GET',
            headers: this.getBearerHeaders(client_id, access_token),
        };
        return fetch(this.OAUTH2_URLS.VALIDATE, options).then(this.checkStatus).then(this.toResult);
    }

    /**
     * 
     * @param {string} access_token access token for the given client id
     * 
     */
    async validateToken(access_token: string): Promise<boolean> {
        const options = {
            headers: {
                'Authorization': `OAuth ${access_token}`
            },
            method: 'GET'
        };
        return fetch(this.OAUTH2_URLS.VALIDATE, options).then(this.statusOk);
    }

    /**
     * 
     * @param {string} client_id an application client id
     * @param {string} access_token access token for the given client id
     * 
     */
    async revokeToken(client_id: string, access_token: string): Promise<boolean> {
        const url = `${this.OAUTH2_URLS.REVOKE}?client_id=${client_id}&token=${access_token}`;
        const options = {
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            method: 'POST'
        };
        return fetch(url, options).then(this.statusOk);
    }

    /**
     * 
     * Validate the current access token
     * 
     */
    async validate(): Promise<boolean> {
        return this.validateToken(this.authenticated.access_token);
    }

    /**
     * 
     * Revoke the current access token
     * 
     */
    async revoke(): Promise<boolean> {
        return this.revokeToken(this.client_id, this.authenticated.access_token);
    }

    async request<T>(url: string, options: RequestInit): Promise<T | string> {
        return this.refreshTokenIfNeeded().then(access_token => this.requestWithCredentials<T>(this.client_id, access_token, url, options));
    }

    private async requestWithCredentials<T>(client_id: string, access_token: string, url: string, options: Record<string, any>): Promise<T | string> {
        options.headers = this.getBearerHeaders(client_id, access_token);
        return fetch(url, options).then(this.checkStatus).then(this.result) as Promise<T | string>;
    }
    
    private async result<T>(res: Response): Promise<T | string> {
        const contentType = res.headers.get('content-type');
        if(contentType && contentType.includes('application/json')) return res.json() as T;
        return res.text();
    }
    /**
     * 
     * @param url Fully qualified URL.
     * 
     * @throws When request fails
     * 
     */
     async get<T>(url: string): Promise<T | string> {
        return this.request(url, {
            method: 'GET'
        });
    }

    /**
     * 
     * @param url Fully qualified URL.
     * 
     * @throws When request fails
     * 
     */
     async getEndpoint(url: string): Promise<any | string> {
        return this.fetchEndpoint(url, {
            method: 'GET'
        });
    }

    /**
     * 
     * @param url Fully qualified URL.
     * @param body stringify json object.
     * 
     * @throws When request fails
     * 
     */
    async postEndpoint(url: string, body: BodyInit | null): Promise<any | string> {
        return this.fetchEndpoint(url, {
            method: 'POST',
            body: typeof body !== 'string' ? JSON.stringify(body) : body
        });
    }

    /**
     * 
     * @param url Fully qualified URL.
     * @param body stringify json object.
     * 
     * @throws When request fails
     * 
     */
    async putEndpoint(url: string, body: BodyInit | null): Promise<any | string> {
        return this.fetchEndpoint(url, {
            method: 'PUT',
            body: typeof body !== 'string' ? JSON.stringify(body) : body
        });
    }

    /**
     * 
     * @param url Fully qualified URL.
     * @param body stringify json object.
     * 
     * @throws When request fails
     * 
     */
    async patchEndpoint(url: string, body: BodyInit | null): Promise<any | string> {
        return this.fetchEndpoint(url, {
            method: 'PATCH',
            body: typeof body !== 'string' ? JSON.stringify(body) : body
        });
    }

    /**
     * 
     * @param url Fully qualified URL.
     * 
     * @throws When request fails
     * 
     */
    async deleteEndpoint(url: string): Promise<any | string> {
        return this.fetchEndpoint(url, {
            method: 'DELETE'
        });
    }

    getAuthenticated(): Authenticated {
        return this.authenticated;
    }
}
